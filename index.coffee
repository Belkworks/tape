# Tape

{resolve, join, basename, extname, relative} = require 'path'
{execFileSync} = require 'child_process'
{program} = require 'commander'

ParseCSV = require 'csv-parse/lib/sync'
Mustache = require 'mustache'
Strings = require './strings'
TOML = require 'toml'
_ = require 'lodash'
log = require 'log'
(require 'log-node')()
fs = require 'fs'

toLua = (obj) ->
	if _.isNil obj
		return 'nil'

	unless _.isObject obj
		return JSON.stringify obj

	result = '{'
	isArray = _.isArray obj
	last = _.size(obj) - 1
	i = 0

	_.each obj, (v, k) ->
		v = toLua v
		if isArray
			result += v
		else
			result += "[#{toLua k}]="+v

		if i != last
			result += ','

		i++

	result + '}'

exploreDirectoryRecursive = (dir, T = []) -> # assume dir is resolved
	_.each (fs.readdirSync dir), (name) ->
		path = join dir, name
		stat = fs.statSync path
		if stat.isDirectory()
			exploreDirectoryRecursive path, T
		else T.push path

	T

Transformers =
	'.moon':
		(content, path) -> execFileSync 'moonc',  ['-p', path]

	'.json':
		(content) -> 'return ' + toLua JSON.parse content

	'.csv':
		(content) -> 'return ' + toLua ParseCSV content, skip_empty_lines: true

	'.toml':
		(content) -> 'return ' + toLua TOML.parse content

	'.txt':
		(content) -> 'return ' + toLua content

	'.lua':
		_.identity

getFileTransformer = (path) ->
	Transformers[extname path]

cleanup = (dist) -> # assume dist is resolved
	if fs.existsSync dist
		fs.rmdirSync dist, recursive: true

	fs.mkdirSync dist
	path = join dist, 'dist.lua'
	fs.writeFileSync path, '-- generated by tape\n'

removeExtension = (path) ->
	path.substring 0, path.length - (extname path).length

findMain = (dir, name = 'main') ->
	for path in fs.readdirSync dir # assume dir exists
		if name == removeExtension path
			return path

	throw new Error 'no main!'

getModuleName = (dir, path) ->
	base = removeExtension path
	s = (relative dir, base)
	while s.includes '\\'
		s = s.replace '\\', '/'

	s

appendText = (dist, text) ->
	path = join dist, 'dist.lua'
	fs.appendFileSync path, text

appendPrelude = (dist) ->
	appendText dist, Strings.prelude

appendModule = (dist, obj) ->
	_.defaults obj, content: '', name: _.uniqueId 'unknown'
	rendered = Mustache.render Strings.template, obj
	appendText dist, rendered

bundle = (dir, out, main) -> # assume dir exists
	main = findMain dir, main
	cleanup out
	files = exploreDirectoryRecursive dir
	
	unless files.length
		return

	appendPrelude out

	transformedMain = undefined

	for path in files
		T = getFileTransformer path
		if T
			name = getModuleName dir, path
			content = (fs.readFileSync path).toString 'utf8'
			transformed = _.trim T content, path

			if main == basename path
				if transformedMain
					throw new Error 'multiple mains!'

				transformedMain = transformed
				continue

			appendModule out, {name, content: transformed}

	appendText out, '\n-- main\n'
	appendText out, transformedMain + '\n'

program
	.arguments('<in>')
	.description 'tape bundler',
		in: 'the input directory'
		out: 'the output directory'
	.action (src) ->
		bundle (resolve src), resolve './dist'

program.parse process.argv

